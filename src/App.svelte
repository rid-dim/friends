<script lang="ts">
  import { onMount } from 'svelte';
  import { browser } from '$app/environment';
  
  // Import components
  import StatusBar from './lib/components/StatusBar.svelte';
  import FriendsList from './lib/components/FriendsList.svelte';
  import Chat from './lib/components/Chat.svelte';
  import type { Friend } from './lib/components/FriendsList.svelte';
  import AccountSettings from './lib/components/AccountSettings.svelte';
  
  // Import WebRTC and file handling
  import { ConnectionManager } from './lib/webrtc/ConnectionManager';
  import type { FileAttachment } from './lib/file-handling/types';
  
  // Import styles
  import './lib/styles/theme.css';
  
  // Import translations
  import { translations } from './lib/i18n/translations';
  
  // Backend and account package related types
  interface AccountPackage {
    version: number; // Version of the account package format
    username: string;
    profileImage?: string; // datamap address
    themeUrl?: string; // theme URL
    language?: 'en' | 'de';
    friends?: Array<{
      peerId?: string; // Optional - can be added later
      displayName: string;
      scratchpadAddress?: string; // The scratchpad address for this friend
    }>;
    activeSession?: {
      sessionId: string;
      timestamp: number; // Unix timestamp in milliseconds
    };
  }
  
  // Application state
  let accountPackage: AccountPackage | null = null;
  let backendUrl = '';
  let accountName = '';
  let profileId = '';
  let isLoadingPeerId = false;
  let isLoadingAccountPackage = false;
  let showAccountCreation = false;
  let accountCreationForm = {
    username: '',
    profileImage: '',
    themeUrl: '',
    language: 'en' as const
  };
  let accountCreationError = '';
  
  // Friends and chat state
  let friends: Friend[] = [];
  let selectedFriendId: string | null = null;
  let chatMessages: Record<string, Array<{
    nick: string;
    text: string;
    timestamp: Date;
    isSelf: boolean;
    attachment?: FileAttachment;
  }>> = {};
  
  // Connection management
  let connectionManager: ConnectionManager;
  let handshakeServerUrl = 'https://handshake.autonomi.space';
  let handshakeStatus = '';
  let handshakeCountdown = '';
  let handshakeCountdowns: Record<string, number | {
    text: string;
    dots?: string;
    seconds?: number;
    isConnecting: boolean;
  }> = {};
  let handshakeLoopRunning = false;
  
  // UI state
  let notification = '';
  let connectionStatus = 'Initializing...';
  let notificationStatus = '';
  
  // Session management
  let currentSessionId = '';
  let sessionCheckInterval: ReturnType<typeof setInterval> | null = null;
  let isSessionActive = true;
  let lastSessionCheck = 0;
  let sessionStartTimestamp = 0;
  
  // Language state
  let language: 'en' | 'de' = 'en';
  
  // Update language when account package changes
  $: if (accountPackage?.language) {
    language = accountPackage.language;
  }
  
  // Get translations for current language
  $: t = translations[language];
  
  // Initialize connection manager
  onMount(() => {
    const rtcConfig: RTCConfiguration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun1.l.google.com:19302' }
      ]
    };
    connectionManager = new ConnectionManager({
      onMessage: handleIncomingMessage,
      onConnectionStateChange: handleConnectionStateChange,
      onError: handleConnectionError
    });
    
    // Parse URL parameters
    backendUrl = parseBackendUrl();
    accountName = parseAccountName();
    
    // Request notification permission for push notifications
    requestNotificationPermission();
    
    // Initialize backend integration
    initializeBackend();
    
    // Log debug info
    console.log('üöÄ Friends App Started');
    console.log('üì¶ Debug info available at: sessionStorage.friendsDebugInfo');
    console.log('üîç To view: JSON.parse(sessionStorage.getItem("friendsDebugInfo"))');
    
    // Start countdown updates
    setInterval(updateCountdowns, 1000);
    
    // Start handshake loop with smokesigns integration
    startHandshakeLoop();
    
    return () => {
      // Cleanup
      connectionManager.closeAllConnections();
      handshakeLoopRunning = false;
      
      // Stop session monitoring
      if (sessionCheckInterval) {
        clearInterval(sessionCheckInterval);
        sessionCheckInterval = null;
      }
    };
  });
  
  // Parse backend URL from query parameters
  function parseBackendUrl(): string {
    if (!browser) return '';
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('backend') || ''; // Empty string means use relative URLs
  }
  
  // Parse account name from query parameters
  function parseAccountName(): string {
    if (!browser) return '';
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('accountname') || '';
  }
  
  // Build scratchpad URL with optional object_name parameter
  function buildScratchpadUrl(): string {
    const baseUrl = backendUrl ? `${backendUrl}/ant-0/scratchpad-private` : '/ant-0/scratchpad-private';
    if (accountName) {
      return `${baseUrl}?object_name=${encodeURIComponent(accountName)}`;
    }
    return baseUrl;
  }
  
  // Build communication object name for public scratchpad
  function buildCommObjectName(): string {
    if (accountName) {
      return `comm${accountName}`;
    }
    return 'comm';
  }
  
  // Build public scratchpad URL for peer communication
  function buildPublicScratchpadUrl(): string {
    const objectName = buildCommObjectName();
    const baseUrl = backendUrl ? `${backendUrl}/ant-0/scratchpad-public` : '/ant-0/scratchpad-public';
    return `${baseUrl}?object_name=${encodeURIComponent(objectName)}`;
  }
  
  // Build friend-specific scratchpad URL
  function buildFriendScratchpadUrl(friendName: string): string {
    const objectName = accountName ? `${friendName}comm${accountName}` : `${friendName}comm`;
    const baseUrl = backendUrl ? `${backendUrl}/ant-0/scratchpad-public` : '/ant-0/scratchpad-public';
    return `${baseUrl}?object_name=${encodeURIComponent(objectName)}`;
  }
  
  // Create or get friend scratchpad
  async function createOrGetFriendScratchpad(friendName: string): Promise<string> {
    const url = buildFriendScratchpadUrl(friendName);
    console.log('üåê Creating/getting friend scratchpad:', url);
    
    try {
      // First try to get existing scratchpad
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'accept': 'application/json',
          'Ant-App-ID': 'friends'
        }
      });
      
      if (response.ok) {
        const scratchpadData = await response.json();
        
        let chunk = null;
        if (Array.isArray(scratchpadData) && scratchpadData.length > 0) {
          chunk = scratchpadData[0];
        } else if (scratchpadData && scratchpadData.dweb_type === "PublicScratchpad") {
          chunk = scratchpadData;
        }
        
        // Pr√ºfe beide m√∂glichen Felder: scratchpad_address oder network_address
        if (chunk) {
          const address = chunk.scratchpad_address || chunk.network_address;
          if (address) {
            console.log('‚úÖ Found existing friend scratchpad:', address);
            return address;
          }
        }
      } else if (response.status === 404) {
        // Create new scratchpad
        const friendInfo = {
          type: 'friend-communication',
          friendName: friendName,
          createdAt: new Date().toISOString(),
          accountName: accountName || null
        };
        
        const friendInfoJson = JSON.stringify(friendInfo);
        const friendInfoBytes = jsonToByteArray(friendInfoJson);
        
        const scratchpadPayload = {
          counter: 0,
          data_encoding: 0,
          dweb_type: "PublicScratchpad",
          encrypted_data: [0],
          scratchpad_address: "string",
          unencrypted_data: friendInfoBytes
        };
        
        const createResponse = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Ant-App-ID': 'friends'
          },
          body: JSON.stringify(scratchpadPayload)
        });
        
        if (!createResponse.ok) {
          throw new Error(`HTTP ${createResponse.status}: ${createResponse.statusText}`);
        }
        
        const createdScratchpad = await createResponse.json();
        console.log('üì¶ Server response for scratchpad creation:', createdScratchpad);
        
        // Pr√ºfe beide m√∂glichen Felder: scratchpad_address oder network_address
        if (createdScratchpad) {
          const address = createdScratchpad.scratchpad_address || createdScratchpad.network_address;
          if (address) {
            console.log('‚úÖ Created new friend scratchpad:', address);
            return address;
          }
        }
      }
      
      throw new Error('Failed to create or get friend scratchpad');
    } catch (error) {
      console.error('‚ùå Error with friend scratchpad:', error);
      throw error;
    }
  }
  
  // Convert JSON to byte array for scratchpad storage
  function jsonToByteArray(jsonString: string): number[] {
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(jsonString);
    return Array.from(uint8Array);
  }
  
  // Convert byte array back to JSON
  function byteArrayToJson(byteArray: number[]): any {
    const uint8Array = new Uint8Array(byteArray);
    const decoder = new TextDecoder();
    const jsonString = decoder.decode(uint8Array);
    return JSON.parse(jsonString);
  }
  
  // Generate a unique session ID
  function generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // Initialize session management
  async function initializeSession() {
    if (!accountPackage) return;
    
    // Generate new session ID
    currentSessionId = generateSessionId();
    sessionStartTimestamp = Date.now();
    
    console.log('üîê Initializing session:', currentSessionId, 'at timestamp:', sessionStartTimestamp);
    
    // The new instance takes over - update account package with new session
    // This will cause the old instance to detect the change and shut down
    await updateAccountPackage({
      activeSession: {
        sessionId: currentSessionId,
        timestamp: sessionStartTimestamp
      }
    });
    
    console.log('üîê Session initialized and registered');
    
    // Start session monitoring
    startSessionMonitoring();
  }
  
  // Start monitoring for other sessions
  function startSessionMonitoring() {
    // Clear any existing interval
    if (sessionCheckInterval) {
      clearInterval(sessionCheckInterval);
    }
    
    // Check every 30 seconds (less aggressive to avoid race conditions)
    sessionCheckInterval = setInterval(async () => {
      lastSessionCheck = Date.now();
      await checkForActiveSession();
    }, 30000);
    
    console.log('üëÅÔ∏è Session monitoring started (30s intervals)');
  }
  
  // Check if another session has taken over
  async function checkForActiveSession() {
    if (!isSessionActive || !accountPackage) return;
    
    try {
      // Fetch latest account package
      const latestPackage = await fetchAccountPackage();
      
      if (latestPackage?.activeSession) {
        const currentTimestamp = Date.now();
        const timeDiff = currentTimestamp - latestPackage.activeSession.timestamp;
        
        console.log(`üîç Session check - Current: ${currentSessionId} (started: ${sessionStartTimestamp}), Remote: ${latestPackage.activeSession.sessionId} (timestamp: ${latestPackage.activeSession.timestamp}), TimeDiff: ${timeDiff}ms`);
        
        // If another session is newer than our session start time and it's not us
        if (latestPackage.activeSession.timestamp > sessionStartTimestamp && latestPackage.activeSession.sessionId !== currentSessionId) {
          console.log('‚ö†Ô∏è Newer session detected, shutting down this instance');
          await handleSessionTransfer();
        }
        // Don't update timestamp - sessions should only register once at startup
      }
    } catch (error) {
      console.error('Error checking active session:', error);
    }
  }
  
  // Handle session transfer to another instance
  async function handleSessionTransfer() {
    isSessionActive = false;
    
    // Close all connections
    connectionManager?.closeAllConnections();
    
    // Stop all intervals
    if (sessionCheckInterval) {
      clearInterval(sessionCheckInterval);
      sessionCheckInterval = null;
    }
    
    // Stop handshake loop
    handshakeLoopRunning = false;
    
    // Update UI
    connectionStatus = t.sessionTransferred;
    showNotification(t.sessionTransferred);
    
    // Disable all interactive elements
    friends = friends.map(f => ({ ...f, isConnected: false }));
  }
  
  // Initialize backend integration
  async function initializeBackend() {
    console.log('üîß Initializing backend integration...');
    console.log('üîß Backend URL:', backendUrl || 'Using relative URLs');
    console.log('üîß Account name:', accountName || 'None provided');
    
    isLoadingAccountPackage = true;
    
    try {
      // Fetch account package
      const fetchedPackage = await fetchAccountPackage();
      
      if (fetchedPackage) {
        accountPackage = fetchedPackage;
        
        // Load friends from account package
        if (fetchedPackage.friends) {
          friends = fetchedPackage.friends.map(f => ({
            peerId: f.peerId,
            displayName: f.displayName,
            scratchpadAddress: f.scratchpadAddress,
            isConnected: false,
            unreadCount: 0
          }));
          
          // Automatically select first friend if there are any
          if (friends.length > 0) {
            console.log('üîç Automatically selecting first friend:', friends[0].displayName);
            // Use peerId if available, otherwise use displayName
            selectedFriendId = friends[0].peerId || friends[0].displayName;
          }
        }
        
        // Load theme if available
        if (fetchedPackage.themeUrl) {
          loadTheme(fetchedPackage.themeUrl);
        }
        
        // Load language if available
        if (fetchedPackage.language) {
          language = fetchedPackage.language;
        }
        
        showNotification(`Welcome back, ${fetchedPackage.username}!`);
        
        // Initialize session management
        await initializeSession();
      } else {
        // No account package found - offer to create one
        showAccountCreation = true;
      }
    } catch (error) {
      console.error('‚ùå Error during backend initialization:', error);
      connectionStatus = 'Backend error';
    } finally {
      isLoadingAccountPackage = false;
    }
    
    // Initialize peer communication only if session is active
    if (isSessionActive) {
      await initializePeerCommunication();
    }
    
    // Update debug info
    updateSessionStorageDebugInfo();
    
    // Start auto-reconnect for all friends only if session is active
    if (isSessionActive) {
      startAutoReconnect();
    }
  }
  
  // Fetch account package from backend
  async function fetchAccountPackage(): Promise<AccountPackage | null> {
    const url = buildScratchpadUrl();
    console.log('üåê Fetching account package from:', url);
    
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'accept': 'application/json',
          'Ant-App-ID': 'friends'
        }
      });
      
      if (response.status === 404) {
        console.log('üì≠ Account package not found (404)');
        return null;
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const scratchpadData = await response.json();
      
      // Extract account package from scratchpad format
      let chunk = null;
      if (Array.isArray(scratchpadData) && scratchpadData.length > 0) {
        chunk = scratchpadData[0];
      } else if (scratchpadData && scratchpadData.dweb_type === "PrivateScratchpad") {
        chunk = scratchpadData;
      }
      
      if (chunk && chunk.unencrypted_data && Array.isArray(chunk.unencrypted_data)) {
        try {
          const accountPackage = byteArrayToJson(chunk.unencrypted_data);
          console.log('‚úÖ Successfully loaded account package:', accountPackage);
          
          // Check version and migrate if needed
          if (!accountPackage.version || accountPackage.version < 2) {
            console.log(`üîÑ Migrating account package from version ${accountPackage.version || 0} to version 2`);
            // Remove all friends as they need to be recreated with new scratchpad approach
            accountPackage.friends = [];
            accountPackage.version = 2;
            showNotification('Account package upgraded. Please re-add your friends.');
          }
          
          return accountPackage as AccountPackage;
        } catch (error) {
          console.error('‚ùå Error parsing account package:', error);
          return null;
        }
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching account package:', error);
      
      // Check for HTTPS certificate error
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (backendUrl && backendUrl.startsWith('https://') && errorMessage.includes('Failed to fetch')) {
        accountCreationError = `HTTPS certificate error detected. Please click here to accept the self-signed certificate: ${backendUrl}`;
        showAccountCreation = true;
      }
      
      return null;
    }
  }
  
  // Create account package on backend
  async function createAccountPackage(accountData: AccountPackage): Promise<boolean> {
    console.log('üíæ Creating account package:', accountData);
    
    try {
      const accountJson = JSON.stringify(accountData);
      const accountBytes = jsonToByteArray(accountJson);
      
      const scratchpadPayload = {
        counter: 0,
        data_encoding: 0,
        dweb_type: "PrivateScratchpad",
        encrypted_data: [0],
        scratchpad_address: "string",
        unencrypted_data: accountBytes
      };
      
      const response = await fetch(buildScratchpadUrl(), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Ant-App-ID': 'friends'
        },
        body: JSON.stringify(scratchpadPayload)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      console.log('‚úÖ Account package created successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error creating account package:', error);
      accountCreationError = 'Error creating account: ' + error;
      return false;
    }
  }
  
  // Update account package on backend
  async function updateAccountPackage(updatedData: Partial<AccountPackage>): Promise<boolean> {
    if (!accountPackage) return false;
    
    console.log('üîÑ Updating account package with:', updatedData);
    
    const newAccountData: AccountPackage = {
      ...accountPackage,
      ...updatedData
    };
    
    try {
      const accountJson = JSON.stringify(newAccountData);
      const accountBytes = jsonToByteArray(accountJson);
      
      const scratchpadPayload = {
        counter: 0,
        data_encoding: 0,
        dweb_type: "PrivateScratchpad",
        encrypted_data: [0],
        scratchpad_address: "string",
        unencrypted_data: accountBytes
      };
      
      const response = await fetch(buildScratchpadUrl(), {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Ant-App-ID': 'friends'
        },
        body: JSON.stringify(scratchpadPayload)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      accountPackage = newAccountData;
      console.log('‚úÖ Account package updated successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error updating account package:', error);
      showNotification('Error updating account package: ' + error);
      return false;
    }
  }
  
  // Initialize public scratchpad for peer communication
  async function initializePeerCommunication(): Promise<void> {
    const url = buildPublicScratchpadUrl();
    console.log('üåê Initializing peer communication:', url);
    
    isLoadingPeerId = true;
    
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'accept': 'application/json',
          'Ant-App-ID': 'friends'
        }
      });
      
      if (response.ok) {
        const scratchpadData = await response.json();
        
        let chunk = null;
        if (Array.isArray(scratchpadData) && scratchpadData.length > 0) {
          chunk = scratchpadData[0];
        } else if (scratchpadData && scratchpadData.dweb_type === "PublicScratchpad") {
          chunk = scratchpadData;
        }
        
        // Pr√ºfe beide m√∂glichen Felder: scratchpad_address oder network_address
        if (chunk) {
          const address = chunk.scratchpad_address || chunk.network_address;
          if (address) {
            profileId = address;
            console.log('‚úÖ Retrieved profile ID:', profileId);
          }
        }
      } else if (response.status === 404) {
        // Create new public scratchpad
        await createPublicScratchpad();
      }
    } catch (error) {
      console.error('‚ùå Error initializing peer communication:', error);
      showNotification('Error initializing peer communication');
    } finally {
      isLoadingPeerId = false;
      connectionStatus = 'Ready';
    }
  }
  
  // Create new public scratchpad for peer communication
  async function createPublicScratchpad(): Promise<void> {
    const url = buildPublicScratchpadUrl();
    console.log('üíæ Creating public scratchpad at:', url);
    
    try {
      const peerInfo = {
        type: 'peer-communication',
        createdAt: new Date().toISOString(),
        accountName: accountName || null
      };
      
      const peerInfoJson = JSON.stringify(peerInfo);
      const peerInfoBytes = jsonToByteArray(peerInfoJson);
      
      const scratchpadPayload = {
        counter: 0,
        data_encoding: 0,
        dweb_type: "PublicScratchpad",
        encrypted_data: [0],
        scratchpad_address: "string",
        unencrypted_data: peerInfoBytes
      };
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Ant-App-ID': 'friends'
        },
        body: JSON.stringify(scratchpadPayload)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const createdScratchpad = await response.json();
      console.log('üì¶ Server response for public scratchpad creation:', createdScratchpad);
      
      // Pr√ºfe beide m√∂glichen Felder: scratchpad_address oder network_address
      if (createdScratchpad) {
        const address = createdScratchpad.scratchpad_address || createdScratchpad.network_address;
        if (address) {
          profileId = address;
          console.log('‚úÖ New profile ID:', profileId);
        }
      }
    } catch (error) {
      console.error('‚ùå Error creating public scratchpad:', error);
    }
  }
  
  // Handle account creation form submission
  async function handleAccountCreation() {
    if (!accountCreationForm.username.trim()) {
      accountCreationError = 'Username is required';
      return;
    }
    
    accountCreationError = '';
    isLoadingAccountPackage = true;
    
    // Generate session for new account
    currentSessionId = generateSessionId();
    sessionStartTimestamp = Date.now();
    
    const accountData: AccountPackage = {
      version: 2, // Version 2 of the account package format
      username: accountCreationForm.username.trim(),
      profileImage: accountCreationForm.profileImage.trim() || undefined,
      themeUrl: accountCreationForm.themeUrl.trim() || 'default',
      language: accountCreationForm.language,
      friends: [],
      activeSession: {
        sessionId: currentSessionId,
        timestamp: sessionStartTimestamp
      }
    };
    
    const success = await createAccountPackage(accountData);
    
    if (success) {
      accountPackage = accountData;
      showAccountCreation = false;
      showNotification('Account package created successfully!');
      
      // Start session monitoring
      startSessionMonitoring();
      
      // Initialize peer communication after account creation
      await initializePeerCommunication();
    }
    
    isLoadingAccountPackage = false;
  }
  
  // Cancel account creation
  function cancelAccountCreation() {
    showAccountCreation = false;
    accountCreationForm = { username: '', profileImage: '', themeUrl: '', language: 'en' as const };
    accountCreationError = '';
  }
  
  // Load theme from URL
  function loadTheme(url: string) {
    const existingThemeLink = document.getElementById('dynamic-theme');
    if (existingThemeLink) {
      existingThemeLink.remove();
    }
    
    if (url === 'default') {
      // Remove any custom background
      document.documentElement.style.removeProperty('--theme-background-url');
      return;
    }
    
    let themeFullUrl: string;
    if (url.startsWith('http')) {
      themeFullUrl = url;
    } else {
      // Use backendUrl for constructing theme URL, which defaults to relative if not set
      themeFullUrl = backendUrl ? `${backendUrl}/ant-0/data/${url}` : `/ant-0/data/${url}`;
    }
    
    const themeLink = document.createElement('link');
    themeLink.id = 'dynamic-theme';
    themeLink.rel = 'stylesheet';
    themeLink.href = themeFullUrl;
    
    // When theme loads, check for background datamap
    themeLink.onload = () => {
      const styles = getComputedStyle(document.documentElement);
      const backgroundDatamap = styles.getPropertyValue('--theme-background-datamap').trim();
      
      if (backgroundDatamap && backgroundDatamap !== '' && backgroundDatamap !== 'none') {
        // Remove quotes if present
        const cleanDatamap = backgroundDatamap.replace(/['"]/g, '');
        const backgroundUrl = backendUrl ? 
          `url("${backendUrl}/ant-0/data/${cleanDatamap}")` : 
          `url("/ant-0/data/${cleanDatamap}")`;
        document.documentElement.style.setProperty('--theme-background-url', backgroundUrl);
        
        // Apply background to body
        document.body.style.background = `${backgroundUrl} no-repeat center center fixed`;
        document.body.style.backgroundSize = 'cover';
      }
    };
    
    document.head.appendChild(themeLink);
  }
  
  // Handle incoming messages from peers
  function handleIncomingMessage(peerId: string, data: any) {
    console.log(`üì® Incoming message from ${peerId}:`, data.type);
    
    // Only check session if it's been more than 30 seconds since last check
    // to avoid too frequent checks that could cause race conditions
    const now = Date.now();
    if (isSessionActive && (!lastSessionCheck || now - lastSessionCheck > 30000)) {
      console.log('üí≠ Triggering session check due to incoming message');
      lastSessionCheck = now;
      checkForActiveSession();
    }
    
    // Don't process messages if session is not active
    if (!isSessionActive) {
      console.log('‚ö†Ô∏è Session not active, ignoring message');
      return;
    }
    
    // Initialize chat messages for this peer if needed
    if (!chatMessages[peerId]) {
      chatMessages[peerId] = [];
    }
    
    // Handle different message types
    switch (data.type) {
      case 'chat':
        const message = {
          nick: data.nick,
          text: data.message,
          timestamp: new Date(data.timestamp),
          isSelf: false,
          attachment: data.attachment
        };
        
        chatMessages[peerId] = [...chatMessages[peerId], message];
        
                // Update unread count if not selected
        if (selectedFriendId !== peerId) {
          const friend = friends.find(f => f.peerId === peerId);
          if (friend) {
            friend.unreadCount++;
            friends = friends;
          }
        }

        // Show push notification if:
        // 1. App is in background (tab not visible), OR
        // 2. App is in foreground but the sender's chat is not currently selected
        const shouldShowNotification = (
          document.hidden || // App in background
          selectedFriendId !== peerId // Different chat is selected
        );

        if (shouldShowNotification && data.nick && data.message) {
          const friendName = getFriendName(peerId);
          showBrowserNotification(friendName, data.message, peerId);
        }
        break;
        
      case 'file-start':
        // Handle file transfer start
        handleFileStart(peerId, data);
        break;
        
      case 'file-chunk':
        // Handle file chunk
        handleFileChunk(peerId, data);
        break;
        
      case 'heartbeat':
        // Connection is alive
        console.log(`[${peerId}] Heartbeat received`);
        break;
    }
  }
  
  // Handle connection state changes
  function handleConnectionStateChange(peerId: string, state: RTCPeerConnectionState) {
    const isConnected = state === 'connected';
    updateFriendConnectionStatus(peerId, isConnected);
    
    if (isConnected) {
      console.log(`[${peerId}] Connected!`);
      showNotification(`Connected to ${getFriendName(peerId)}`);
      
      // Clear countdown for this friend
      delete handshakeCountdowns[peerId];
    } else if (state === 'failed' || state === 'disconnected') {
      console.log(`[${peerId}] Disconnected`);
      showNotification(`Disconnected from ${getFriendName(peerId)}`);
      
      // Initialize status display for this friend again
      startAutoReconnectForFriend(peerId);
    }
    
    // Update debug info
    updateSessionStorageDebugInfo();
  }
  
  // Handle connection errors
  function handleConnectionError(peerId: string, error: Error) {
    console.error(`[${peerId}] Connection error:`, error);
    updateFriendConnectionStatus(peerId, false);
  }
  
  // Update friend connection status
  function updateFriendConnectionStatus(peerId: string, isConnected: boolean) {
    const friend = friends.find(f => f.peerId === peerId);
    if (friend) {
      friend.isConnected = isConnected;
      friends = friends;
    }
    
    updateConnectionStatus();
  }
  
  // Update overall connection status
  function updateConnectionStatus() {
    const connectedCount = friends.filter(f => f.isConnected).length;
    
    if (connectedCount === 0) {
      connectionStatus = 'No connections';
    } else if (connectedCount === 1) {
      connectionStatus = '1 friend connected';
    } else {
      connectionStatus = `${connectedCount} friends connected`;
    }
  }
  
  // Get friend display name
  function getFriendName(peerId: string): string {
    const friend = friends.find(f => f.peerId === peerId);
    return friend?.displayName || peerId.slice(0, 8) + '...';
  }
  
  // Handle friend selection
  function handleSelectFriend(event: CustomEvent<string>) {
    selectedFriendId = event.detail;
    
    // Clear unread count
    const friend = friends.find(f => 
      (f.peerId && f.peerId === event.detail) || 
      (!f.peerId && f.displayName === event.detail)
    );
    if (friend) {
      friend.unreadCount = 0;
      friends = friends;
    }
  }
  
  // Handle adding a new friend
  async function handleAddFriend(event: CustomEvent<{peerId: string | undefined, displayName: string}>) {
    const { peerId, displayName } = event.detail;
    
    // Check if friend already exists by display name
    if (friends.some(f => f.displayName === displayName)) {
      showNotification('Friend with this name already exists');
      return;
    }
    
    // Add new friend immediately with loading state
    const newFriend: Friend = {
      peerId,
      displayName,
      scratchpadAddress: undefined, // Will be set after creation
      isConnected: false,
      unreadCount: 0,
      isLoadingScratchpad: true // Add loading state
    };
    
    friends = [...friends, newFriend];
    
    // Always select the new friend to show the loading state
    // and to make it easier for users to interact with the new friend
    selectedFriendId = peerId || displayName;
    
    // Save to localStorage immediately (without scratchpad address)
    saveFriends();
    
    // Create or get friend scratchpad in background
    try {
      const scratchpadAddress = await createOrGetFriendScratchpad(displayName);
      
      // Update friend with scratchpad address
      const friendIndex = friends.findIndex(f => f.displayName === displayName);
      if (friendIndex !== -1) {
        friends[friendIndex] = {
          ...friends[friendIndex],
          scratchpadAddress,
          isLoadingScratchpad: false
        };
        friends = [...friends];
        
        // Save again with scratchpad address
        saveFriends();
        
        showNotification(`Friend ${displayName} added successfully`);
        
        // If friend has peerId, start connection attempt
        if (peerId) {
          startAutoReconnectForFriend(peerId);
        }
      }
    } catch (error) {
      console.error('Error creating friend scratchpad:', error);
      
      // Update friend to show error state
      const friendIndex = friends.findIndex(f => f.displayName === displayName);
      if (friendIndex !== -1) {
        friends[friendIndex] = {
          ...friends[friendIndex],
          isLoadingScratchpad: false,
          scratchpadError: true
        };
        friends = [...friends];
      }
      
      showNotification('Error creating friend scratchpad');
    }
  }
  
  // Handle removing a friend
  function handleRemoveFriend(event: CustomEvent<string>) {
    const id = event.detail;
    
    // Find friend by peerId or displayName
    const friend = friends.find(f => 
      (f.peerId && f.peerId === id) || 
      (!f.peerId && f.displayName === id)
    );
    
    if (!friend) return;
    
    // Close connection if peerId exists
    if (friend.peerId) {
      connectionManager.closeConnection(friend.peerId);
      
      // Clear status display for this friend
      delete handshakeCountdowns[friend.peerId];
      
      // Clear chat messages
      delete chatMessages[friend.peerId];
    }
    
    // Remove from friends list
    friends = friends.filter(f => f !== friend);
    
    // Clear selection if this friend was selected
    if (selectedFriendId === id) {
      // If there are other friends, select the first one
      if (friends.length > 0) {
        console.log('üîç Auto-selecting another friend after removal');
        selectedFriendId = friends[0].peerId || friends[0].displayName;
      } else {
        selectedFriendId = null;
      }
    }
    
    // Save to localStorage
    saveFriends();
    
    showNotification('Friend removed');
  }
  
  // Handle updating peer ID for a friend
  async function handleUpdatePeerId(event: CustomEvent<{peerId: string}>) {
    if (!selectedFriend) return;
    
    const { peerId } = event.detail;
    
    // Update the friend's peerId
    const friendIndex = friends.findIndex(f => f.displayName === selectedFriend.displayName);
    if (friendIndex !== -1) {
      friends[friendIndex] = {
        ...friends[friendIndex],
        peerId
      };
      friends = [...friends];
      
      // Save to localStorage and account package
      saveFriends();
      
      // Start connection attempt
      startAutoReconnectForFriend(peerId);
      
      showNotification(`Peer ID updated for ${selectedFriend.displayName}`);
    }
  }
  
  // Save friends to localStorage
  function saveFriends() {
    if (!browser) return;
    
    const friendsData = friends.map(f => ({
      peerId: f.peerId,
      displayName: f.displayName,
      scratchpadAddress: f.scratchpadAddress
    }));
    
    localStorage.setItem('friends', JSON.stringify(friendsData));
    
    // Also update account package if available
    if (accountPackage) {
      updateAccountPackageFriends(friendsData);
    }
  }
  
  // Update account package with friends list
  async function updateAccountPackageFriends(friendsData: Array<{peerId?: string, displayName: string, scratchpadAddress?: string}>) {
    const success = await updateAccountPackage({ friends: friendsData });
    if (success) {
      console.log('‚úÖ Friends list saved to account package');
    }
  }
  
  // Handle sending a message
  function handleSendMessage(event: CustomEvent<{text: string, attachment: FileAttachment | null}>) {
    if (!selectedFriend) return;
    
    // Check if session is still active
    if (!isSessionActive) {
      showNotification(t.sessionTransferred);
      return;
    }
    
    const { text, attachment } = event.detail;
    
    // Create message object
    const message = {
      nick: accountPackage?.username || 'User',
      text,
      timestamp: new Date(),
      isSelf: true,
      attachment: attachment || undefined
    };
    
    // Use peerId if available, otherwise use displayName as key
    const messageKey = selectedFriend.peerId || selectedFriend.displayName;
    
    // Add to local messages
    if (!chatMessages[messageKey]) {
      chatMessages[messageKey] = [];
    }
    chatMessages[messageKey] = [...chatMessages[messageKey], message];
    
    // Only send via WebRTC if friend has peerId
    if (selectedFriend.peerId) {
      const messageData = {
        type: 'chat',
        nick: message.nick,
        message: text,
        timestamp: message.timestamp.toISOString(),
        attachment: attachment ? {
          ...attachment,
          data: attachment.size > 50000 ? undefined : attachment.data
        } : undefined
      };
      
      if (attachment && attachment.size > 50000 && attachment.data) {
        // Send large files in chunks
        connectionManager.sendLargeFileInChunks(selectedFriend.peerId, messageData, attachment);
      } else {
        connectionManager.sendMessage(selectedFriend.peerId, messageData);
      }
    } else {
      // If no peerId, show message that friend needs to add their peer ID
      showNotification('Friend needs to add their peer ID to receive messages');
    }
  }
  
  // Handle file transfer start
  function handleFileStart(peerId: string, data: any) {
    console.log(`[${peerId}] Receiving file:`, data.attachment.name);
    
    // Initialize chat messages if needed
    if (!chatMessages[peerId]) {
      chatMessages[peerId] = [];
    }
    
    // Add placeholder message
    const message = {
      nick: data.nick,
      text: data.message || '',
      timestamp: new Date(data.timestamp),
      isSelf: false,
      attachment: {
        ...data.attachment,
        complete: false,
        progress: 0
      } as FileAttachment & { progress?: number }
    };
    
    chatMessages[peerId] = [...chatMessages[peerId], message];
    
    // Store file info for chunk assembly
    const messageIndex = chatMessages[peerId].length - 1;
    
    incomingFiles[data.attachment.id] = {
      messageIndex,
      chunks: [],
      totalChunks: data.attachment.totalChunks,
      attachment: data.attachment
    };
  }
  
  // Handle file chunk
  function handleFileChunk(peerId: string, data: any) {
    const fileInfo = incomingFiles[data.attachmentId];
    if (!fileInfo) {
      console.error(`[${peerId}] No file info for chunk:`, data.attachmentId);
      return;
    }
    
    // Store chunk
    fileInfo.chunks[data.chunkIndex] = data.data;
    
    // Update progress
    const progress = Math.round((fileInfo.chunks.filter(c => c !== undefined).length / fileInfo.totalChunks) * 100);
    
    // Update message attachment
    const messages = chatMessages[peerId];
    if (messages && messages[fileInfo.messageIndex]) {
      messages[fileInfo.messageIndex].attachment = {
        ...messages[fileInfo.messageIndex].attachment!,
        progress
      } as FileAttachment & { progress?: number };
      chatMessages[peerId] = [...messages];
    }
    
    // Check if complete
    if (fileInfo.chunks.filter(c => c !== undefined).length === fileInfo.totalChunks) {
      // Reassemble file
      const completeData = fileInfo.chunks.join('');
      
      // Update message with complete file
      if (messages && messages[fileInfo.messageIndex]) {
        messages[fileInfo.messageIndex].attachment = {
          ...fileInfo.attachment,
          data: completeData,
          complete: true,
          progress: 100
        } as FileAttachment & { progress?: number };
        chatMessages[peerId] = [...messages];
      }
      
      // Clean up
      delete incomingFiles[data.attachmentId];
      
      console.log(`[${peerId}] File complete:`, fileInfo.attachment.name);
    }
  }
  
  // Incoming files tracking
  let incomingFiles: Record<string, {
    messageIndex: number;
    chunks: string[];
    totalChunks: number;
    attachment: FileAttachment;
  }> = {};
  
  // Show notification
  function showNotification(message: string) {
    notification = message;
    setTimeout(() => {
      notification = '';
    }, 3000);
  }
  
  // Show browser notification
  function showBrowserNotification(title: string, body: string, peerId?: string) {
    if ('Notification' in window && Notification.permission === 'granted') {
      const notification = new Notification(title, { 
        body, 
        icon: '/favicon.png',
        tag: peerId || 'general', // Prevent duplicate notifications from same sender
        requireInteraction: false // Auto-close after a few seconds
      });
      
      // Make notification clickable to focus the app and select the chat
      notification.onclick = () => {
        window.focus(); // Focus the browser window/tab
        
        if (peerId) {
          // Select the friend's chat
          selectedFriendId = peerId;
          
          // Clear unread count
          const friend = friends.find(f => f.peerId === peerId);
          if (friend) {
            friend.unreadCount = 0;
            friends = friends;
          }
        }
        
        notification.close();
      };
    }
  }
  
  // Request notification permission
  async function requestNotificationPermission() {
    if ('Notification' in window) {
      if (Notification.permission === 'default') {
        const permission = await Notification.requestPermission();
        updateNotificationStatus();
        if (permission === 'granted') {
          showNotification(t.notificationsEnabled);
        } else if (permission === 'denied') {
          showNotification(t.notificationsDenied);
        }
      } else {
        updateNotificationStatus();
      }
    } else {
      notificationStatus = t.notificationsNotSupported;
    }
  }
  
  // Update notification status display
  function updateNotificationStatus() {
    if ('Notification' in window) {
      switch (Notification.permission) {
        case 'granted':
          notificationStatus = t.notificationsActivated;
          break;
        case 'denied':
          notificationStatus = t.notificationsBlocked;
          break;
        case 'default':
          notificationStatus = t.notificationsNotRequested;
          break;
      }
    } else {
      notificationStatus = t.notificationsNotSupported;
    }
  }
  
  // Test function for push notifications (for development/debugging)
  function testPushNotification() {
    if ('Notification' in window && Notification.permission === 'granted') {
      showBrowserNotification('Test Nachricht', 'Dies ist eine Test-Push-Notification!');
      console.log('Test-Push-Notification gesendet');
    } else {
      console.log('Push-Notifications nicht verf√ºgbar oder nicht erlaubt');
      showNotification(t.notificationsNotAvailable);
    }
  }
  
  // Make test function available globally for debugging
  if (browser && typeof window !== 'undefined') {
    (window as any).testPushNotification = testPushNotification;
  }
  
  // Get current chat messages
  $: currentChatMessages = selectedFriend 
    ? (chatMessages[selectedFriend.peerId || selectedFriend.displayName] || []) 
    : [];
  
  // Get selected friend
  $: selectedFriend = friends.find(f => 
    (f.peerId && f.peerId === selectedFriendId) || 
    (!f.peerId && f.displayName === selectedFriendId)
  );
  
  // Update session storage debug info
  function updateSessionStorageDebugInfo() {
    if (!browser) return;
    
    try {
      const debugInfo = {
        accountPackage,
        backendUrl,
        accountName,
        profileId,
        friends,
        selectedFriendId,
        connectionStatus,
        connectedPeers: connectionManager?.getConnectedPeers() || [],
        lastUpdated: new Date().toISOString()
      };
      
      sessionStorage.setItem('friendsDebugInfo', JSON.stringify(debugInfo, null, 2));
    } catch (error) {
      console.warn('Failed to update debug info:', error);
    }
  }
  
  // Update status display for each friend
  let dotCount = 0;
  let dotUpdateCounter = 0;
  
  function updateCountdowns() {
    // Update dot animation counter (changes every 500ms)
    dotUpdateCounter = (dotUpdateCounter + 1) % 2;
    if (dotUpdateCounter === 0) {
      dotCount = (dotCount + 1) % 3;
    }
    
    // Get current time to determine if we're in the connecting phase
    const now = new Date();
    const seconds = now.getSeconds();
    const isConnectingPhase = seconds < 35; // First 35 seconds after full minute
    
    // Update status for all disconnected friends
    friends.forEach(friend => {
      if (!friend.peerId || friend.isConnected) {
        return; // Skip connected friends or those without peerId
      }
      
      // Format the status display
      if (isConnectingPhase) {
        // In connecting phase, show "connecting" with animated dots
        const dots = '.'.repeat(dotCount + 1);
        handshakeCountdowns[friend.peerId] = { 
          text: 'connecting',
          dots: dots,
          isConnecting: true
        };
      } else {
        // After connecting phase, show countdown to next attempt
        const timeToNextMinute = 60 - seconds;
        handshakeCountdowns[friend.peerId] = {
          text: 'retrying in',
          seconds: timeToNextMinute,
          isConnecting: false
        };
      }
    });
    
    // Trigger Svelte reactivity by reassigning the object
    handshakeCountdowns = { ...handshakeCountdowns };
  }
  
  // Start display loop for connection status
  async function startHandshakeLoop() {
    if (handshakeLoopRunning) return;
    handshakeLoopRunning = true;
    
    // Start the countdown update interval
    const intervalId = setInterval(updateCountdowns, 500);
    
    while (handshakeLoopRunning) {
      // Check if all friends are connected
      const disconnectedFriends = friends.filter(f => !f.isConnected && f.peerId);
      if (disconnectedFriends.length === 0) {
        // All friends are connected, stop the loop
        handshakeLoopRunning = false;
        clearInterval(intervalId);
        console.log('All friends connected, stopping status display loop');
        break;
      }
      
      // Try to connect to disconnected friends at the start of each minute
      const now = new Date();
      const seconds = now.getSeconds();
      
      if (seconds === 0) {
        console.log('‚è∞ Full minute reached, attempting connections to disconnected friends');
        disconnectedFriends.forEach(friend => {
          if (friend.peerId && canStartHandshake(friend.peerId)) {
            console.log(`[${friend.peerId}] Attempting connection at ${now.toISOString()}`);
            startHandshakeForFriend(friend.peerId);
          }
        });
      }
      
      // Sleep for 1s before next check
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  // Initialize status display and connections for all friends
  function startAutoReconnect() {
    // Only initialize status for disconnected friends
    friends.forEach(friend => {
      // If friend is already connected, don't interfere
      if (friend.isConnected) {
        return;
      }
      
      // Skip friends without peerId
      if (!friend.peerId) {
        return;
      }
      
      // Use the startAutoReconnectForFriend function to ensure consistency
      startAutoReconnectForFriend(friend.peerId);
    });
    
    // Start the handshake loop if not already running
    if (!handshakeLoopRunning) {
      startHandshakeLoop();
    }
  }
  
  // Initialize status display and connection for a specific friend
  function startAutoReconnectForFriend(peerId: string) {
    // Check current connection state
    const connection = connectionManager.getConnection(peerId);
    if (connection && connection.isConnected) {
      console.log(`[${peerId}] Already connected, not showing status`);
      return;
    }
    
    // Initialize status display
    console.log(`[${peerId}] Initializing connection status display`);
    
    // Start the connection attempt
    startHandshakeForFriend(peerId);
    
    // Start the handshake loop if not already running
    if (!handshakeLoopRunning) {
      startHandshakeLoop();
    }
  }
  
  // Start handshake for a specific friend
  async function startHandshakeForFriend(peerId: string) {
    if (!profileId || !peerId) return;
    
    // Check if we're already trying to connect to this peer
    const existingConnection = connectionManager.getConnection(peerId);
    if (existingConnection && (existingConnection.isConnecting || existingConnection.isConnected)) {
      console.log(`[${peerId}] Connection already ${existingConnection.isConnected ? 'established' : 'in progress'}`);
      return;
    }
    
    // Close any existing failed connection before creating a new one
    if (existingConnection) {
      console.log(`[${peerId}] Closing existing connection before creating new one`);
      connectionManager.closeConnection(peerId);
      // Wait a bit for cleanup
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    try {
      // Find the friend to get their scratchpad address
      const friend = friends.find(f => f.peerId === peerId);
      if (!friend || !friend.scratchpadAddress) {
        console.error(`No scratchpad address found for friend ${peerId}`);
        return;
      }
      
      // Determine priority based on contact ID comparison (friend-specific)
      const isHighPriority = calculateFriendPriority(friend);
      
      // Ensure we have valid addresses (non-undefined)
      const myAddress = friend.scratchpadAddress;
      if (!myAddress) {
        console.error(`[${peerId}] Missing my scratchpad address for connection`);
        return;
      }
      
      console.log(`[${peerId}] Using smokesigns for connection with priority: ${isHighPriority ? 'true (initiator)' : 'false (responder)'}`);
      console.log(`[${peerId}] Using addresses: read=${peerId}, write=${myAddress}`);
      
      // Create new connection using smokesigns integration
      connectionManager.createConnectionUsingSigns(
        peerId,
        myAddress,  // My address (write to)
        peerId,     // Their address (read from)
        isHighPriority // Priority based on ID comparison
      );
      
    } catch (error) {
      console.error(`[${peerId}] Handshake failed:`, error);
      updateFriendConnectionStatus(peerId, false);
    }
  }
  
  // Validate that contact ID is in correct handshake server format (96-char hex)
  function validateHandshakeAddress(contactId: string): boolean {
    const hexPattern = /^[a-f0-9]{96}$/;
    return hexPattern.test(contactId);
  }

  // Check if we have the necessary data to start a handshake
  function canStartHandshake(peerId: string): boolean {
    if (!profileId || !peerId) return false;
    
    const friend = friends.find(f => f.peerId === peerId);
    return !!(friend && friend.scratchpadAddress);
  }

  // Calculate priority for a specific friend based on contact IDs
  function calculateFriendPriority(friend: any): boolean {
    if (!friend.scratchpadAddress) return false;
    
    const myContactId = friend.scratchpadAddress; // My contact ID for this friend
    const theirPeerId = friend.peerId; // Their peer ID (their contact ID for me)
    
    // Convert IDs to numbers for comparison
    // Use a simple hash of the first 16 hex characters
    const myValue = parseInt(myContactId.substring(0, 16), 16);
    const theirValue = parseInt(theirPeerId.substring(0, 16), 16);
    
    // Higher value has priority and creates the offer
    const isHighPriority = myValue > theirValue;
    
    // console.log(`[${friend.peerId}] Priority calculation:`);
    // console.log(`  My contact ID: ${myContactId.substring(0, 16)}... = ${myValue}`);
    // console.log(`  Their peer ID: ${theirPeerId.substring(0, 16)}... = ${theirValue}`);
    // console.log(`  I have priority: ${isHighPriority}`);
    
    return isHighPriority;
  }
</script>

<div class="app">
  <!-- Loading overlay for account package fetching -->
  {#if isLoadingAccountPackage}
    <div class="loading-overlay">
      <div class="loading-content">
        <div class="spinner"></div>
        <p>Fetching account package...</p>
      </div>
    </div>
  {/if}

  <!-- Account creation modal -->
  {#if showAccountCreation}
    <div class="modal-overlay">
      <div class="modal-content">
        <h2>Create Account Package</h2>
        <p>No account package found. Would you like to create one?</p>
        
        <form on:submit|preventDefault={handleAccountCreation}>
          <!-- Show certificate error with clickable link -->
          {#if accountCreationError.includes('HTTPS certificate error detected')}
            <div class="certificate-error">
              <p><strong>üîí HTTPS Certificate Issue Detected</strong></p>
              <p>The backend uses a self-signed certificate. Please click the link below to accept it:</p>
              <a href={backendUrl} target="_blank" rel="noopener noreferrer" class="certificate-link">
                {backendUrl}
              </a>
              <p><small>After accepting the certificate, close this window and try again.</small></p>
              <div class="modal-buttons">
                <button type="button" on:click={cancelAccountCreation} class="secondary-button">
                  Close
                </button>
                <button type="button" on:click={() => {
                  accountCreationError = '';
                  initializeBackend();
                }} class="primary-button">
                  Try Again
                </button>
              </div>
            </div>
          {:else}
          <div class="input-group">
            <label for="create-username">Username</label>
            <input 
              id="create-username"
                type="text"
              bind:value={accountCreationForm.username}
              placeholder="Enter your username"
              required
              />
          </div>
          
          <div class="input-group">
              <label for="create-profile-image">Profile Image (optional)</label>
            <input 
              id="create-profile-image"
                type="text"
              bind:value={accountCreationForm.profileImage}
                placeholder="Datamap address or URL"
              />
          </div>
          
          <div class="input-group">
              <label for="create-theme">Theme</label>
              <select id="create-theme" bind:value={accountCreationForm.themeUrl}>
                <option value="default">Default</option>
              </select>
          </div>
          
            {#if accountCreationError && !accountCreationError.includes('HTTPS')}
              <div class="error-message">
                {accountCreationError}
              </div>
          {/if}
          
          <div class="modal-buttons">
            <button type="button" on:click={cancelAccountCreation} class="secondary-button">
              Cancel
            </button>
            <button type="submit" class="primary-button" disabled={isLoadingAccountPackage}>
                Create Account
            </button>
          </div>
          {/if}
        </form>
      </div>
    </div>
  {/if}

  <StatusBar 
    appTitle="Friends"
    {connectionStatus}
    {handshakeStatus}
    {handshakeCountdown}
    {notificationStatus}
  />
  
  <div class="container">
    <div class="sidebar">
      <AccountSettings
        profileImage={accountPackage?.profileImage || ''}
        themeUrl={accountPackage?.themeUrl || ''}
        {language}
        {backendUrl}
        on:update={async ({detail}) => {
          if (accountPackage) {
            const success = await updateAccountPackage({
              ...accountPackage,
              [detail.field]: detail.value
            });
            if (success) {
              showNotification(t.settingsUpdated);
            }
          }
        }}
      />
      
      <FriendsList
        {friends}
        {selectedFriendId}
        {profileId}
        myUsername={accountPackage?.username || 'User'}
        {handshakeCountdowns}
        {language}
        on:selectFriend={handleSelectFriend}
        on:addFriend={handleAddFriend}
        on:removeFriend={handleRemoveFriend}
        on:notification={(e) => showNotification(e.detail)}
      />
        </div>
        
    <div class="main-content">
      <Chat
        messages={currentChatMessages}
        myNick={accountPackage?.username || 'User'}
        isConnected={selectedFriend?.isConnected || false}
        friendName={selectedFriend?.displayName || ''}
        friendPeerId={selectedFriend?.peerId || ''}
        friendScratchpadAddress={selectedFriend?.scratchpadAddress || ''}
        isLoadingScratchpad={selectedFriend?.isLoadingScratchpad || false}
        scratchpadError={selectedFriend?.scratchpadError || false}
        {language}
        on:sendMessage={handleSendMessage}
        on:notification={(e) => showNotification(e.detail)}
        on:updatePeerId={handleUpdatePeerId}
      />
              </div>
                </div>
  
  {#if notification}
    <div class="notification">
      {notification}
                </div>
                  {/if}
  
  {#if !isSessionActive}
    <div class="session-overlay">
      <div class="session-message">
        <h2>‚ö†Ô∏è {t.sessionTransferred}</h2>
        <p>{t.sessionDeactivatedMessage}</p>
        <button class="primary-button" on:click={() => window.location.reload()}>
          {t.reload}
        </button>
      </div>
    </div>
  {/if}
                </div>

<style>
  .app {
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  .loading-content {
    background: var(--background-color);
    padding: 2rem;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  }
  
  .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid var(--foreground-color1);
    border-top-color: var(--notification-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  .modal-content {
    background: var(--background-color);
    padding: 2rem;
    border-radius: 12px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  }
  
  .modal-content h2 {
    margin: 0 0 1rem 0;
  }
  
  .input-group {
    margin-bottom: 1rem;
  }
  
  .input-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
  }
  
  .input-group input,
  .input-group select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--line-color);
    border-radius: 6px;
    background: var(--background-color);
    color: inherit;
    font-size: 0.9rem;
  }
  
  .certificate-error {
    background: var(--foreground-color1);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
  }
  
  .certificate-link {
    display: inline-block;
    margin: 0.5rem 0;
    color: var(--notification-color);
    text-decoration: underline;
  }
  
  .error-message {
    color: var(--notification-color);
    margin-bottom: 1rem;
    padding: 0.5rem;
    background: rgba(255, 0, 0, 0.1);
    border-radius: 4px;
  }
  
  .modal-buttons {
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
    margin-top: 1.5rem;
  }
  
  .primary-button,
  .secondary-button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  
  .primary-button {
    background: var(--notification-color);
    color: white;
  }
  
  .secondary-button {
    background: var(--foreground-color2);
    color: var(--text-color);
  }
  
  .primary-button:hover:not(:disabled),
  .secondary-button:hover {
    opacity: 0.8;
  }
  
  .primary-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--notification-color);
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    animation: slideIn 0.3s ease-out;
    z-index: 1000;
  }
  
  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  
  .session-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
  }
  
  .session-message {
    background: var(--background-color);
    padding: 2rem;
    border-radius: 12px;
    text-align: center;
    max-width: 400px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }
  
  .session-message h2 {
    margin: 0 0 1rem 0;
    color: var(--notification-color);
  }
  
  .session-message p {
    margin: 0 0 1.5rem 0;
    opacity: 0.8;
  }
  
  .sidebar {
    display: flex;
    flex-direction: column;
    width: 300px;
    border-right: 1px solid var(--line-color);
    overflow-y: auto; /* Enable vertical scrolling */
    max-height: 100%; /* Ensure it doesn't exceed container height */
    padding-bottom: 10px; /* Add some bottom padding for better scrolling experience */
  }
</style> 